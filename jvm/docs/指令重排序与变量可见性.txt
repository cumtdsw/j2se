http://ifeve.com/syn-jmm-pre/
【指令重排序】
按我的理解简单的说，就是在“不导致逻辑错误”的前提下，编译器或JIT会对指令进行重排序。

例如：代码段：
a++;
b++;
// 其它代码。串行环境上面2行代码调换顺序执行或交叉执行，对下面的代码都是无差别的。
但是在多线程环境中，就可能出现不确定的状况。

【变量可见性】
由于CPU高速缓存的存在，在高速缓存里变化到的变量并不保证马上写回内存。
例如：代码段：
class A {
    private int a = 0;
    public void incr() {a++;}
    public int get(){return a;}
}
如果多个线程访问incr和get方法，jvm不保证一个线程更新完a之后，
另一个线程get拿到最新的a值。

【解决方案】
1) 同步。

在Java存储模型（Java Memory Model, JMM）中，重排序是十分重要的一节，
特别是在并发编程中。JMM通过happens-before法则保证顺序执行语义，
如果想要让执行操作B的线程观察到执行操作A的线程的结果，
那么A和B就必须满足happens-before原则，
否则，JVM可以对它们进行任意排序以提高程序性能。

[happens-before法则]重要!
http://blog.csdn.net/ns_code/article/details/17348313

2) volatile关键字可以保证变量的可见性。
volatile还有一个作用就是局部阻止重排序的发生，
对volatile变量的操作指令都不会被重排序，
因为如果重排序，又可能产生可见性问题。

在保证可见性方面，锁（包括显式锁、对象锁）以及对原子变量的读写都可以确保变量的可见性。
但是实现方式略有不同，例如同步锁保证得到锁时从内存里重新读入数据刷新缓存，
释放锁时将数据写回内存以保数据可见，而volatile变量干脆都是读写内存。